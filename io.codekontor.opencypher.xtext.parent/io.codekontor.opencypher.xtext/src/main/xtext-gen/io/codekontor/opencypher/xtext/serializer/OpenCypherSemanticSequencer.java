/*
 * generated by Xtext 2.25.0
 */
package io.codekontor.opencypher.xtext.serializer;

import com.google.inject.Inject;
import io.codekontor.opencypher.xtext.openCypher.AddOrSubtractExpression;
import io.codekontor.opencypher.xtext.openCypher.All;
import io.codekontor.opencypher.xtext.openCypher.AllOptions;
import io.codekontor.opencypher.xtext.openCypher.AllShortestPaths;
import io.codekontor.opencypher.xtext.openCypher.AndExpression;
import io.codekontor.opencypher.xtext.openCypher.Any;
import io.codekontor.opencypher.xtext.openCypher.BooleanLiteral;
import io.codekontor.opencypher.xtext.openCypher.BulkImportQuery;
import io.codekontor.opencypher.xtext.openCypher.CaseAlternatives;
import io.codekontor.opencypher.xtext.openCypher.CaseExpression;
import io.codekontor.opencypher.xtext.openCypher.CombinedQuery;
import io.codekontor.opencypher.xtext.openCypher.ComparisonExpression;
import io.codekontor.opencypher.xtext.openCypher.ConfigurationOption;
import io.codekontor.opencypher.xtext.openCypher.ContainsExpression;
import io.codekontor.opencypher.xtext.openCypher.Count;
import io.codekontor.opencypher.xtext.openCypher.Create;
import io.codekontor.opencypher.xtext.openCypher.CreateIndex;
import io.codekontor.opencypher.xtext.openCypher.Cypher;
import io.codekontor.opencypher.xtext.openCypher.CypherOption;
import io.codekontor.opencypher.xtext.openCypher.DecimalInteger;
import io.codekontor.opencypher.xtext.openCypher.Delete;
import io.codekontor.opencypher.xtext.openCypher.DropIndex;
import io.codekontor.opencypher.xtext.openCypher.DropNodePropertyExistenceConstraint;
import io.codekontor.opencypher.xtext.openCypher.DropRelationshipPropertyExistenceConstraint;
import io.codekontor.opencypher.xtext.openCypher.DropUniqueConstraint;
import io.codekontor.opencypher.xtext.openCypher.EndsWithExpression;
import io.codekontor.opencypher.xtext.openCypher.ExplicitProcedureInvocation;
import io.codekontor.opencypher.xtext.openCypher.Extract;
import io.codekontor.opencypher.xtext.openCypher.Filter;
import io.codekontor.opencypher.xtext.openCypher.FilterExpression;
import io.codekontor.opencypher.xtext.openCypher.Foreach;
import io.codekontor.opencypher.xtext.openCypher.FunctionInvocation;
import io.codekontor.opencypher.xtext.openCypher.IdInColl;
import io.codekontor.opencypher.xtext.openCypher.IdLookup;
import io.codekontor.opencypher.xtext.openCypher.IdentifiedIndexLookup;
import io.codekontor.opencypher.xtext.openCypher.ImplicitProcedureInvocation;
import io.codekontor.opencypher.xtext.openCypher.InCollectionExpression;
import io.codekontor.opencypher.xtext.openCypher.InQueryCall;
import io.codekontor.opencypher.xtext.openCypher.Index;
import io.codekontor.opencypher.xtext.openCypher.IndexHint;
import io.codekontor.opencypher.xtext.openCypher.IndexLookupExpression;
import io.codekontor.opencypher.xtext.openCypher.IndexQuery;
import io.codekontor.opencypher.xtext.openCypher.IndexRangeExpression;
import io.codekontor.opencypher.xtext.openCypher.IsNotNullExpression;
import io.codekontor.opencypher.xtext.openCypher.IsNullExpression;
import io.codekontor.opencypher.xtext.openCypher.JoinHint;
import io.codekontor.opencypher.xtext.openCypher.LegacyParameter;
import io.codekontor.opencypher.xtext.openCypher.Limit;
import io.codekontor.opencypher.xtext.openCypher.ListComprehension;
import io.codekontor.opencypher.xtext.openCypher.ListLiteral;
import io.codekontor.opencypher.xtext.openCypher.LiteralIds;
import io.codekontor.opencypher.xtext.openCypher.LoadCSV;
import io.codekontor.opencypher.xtext.openCypher.LoadCSVQuery;
import io.codekontor.opencypher.xtext.openCypher.MapLiteral;
import io.codekontor.opencypher.xtext.openCypher.MapLiteralEntry;
import io.codekontor.opencypher.xtext.openCypher.Match;
import io.codekontor.opencypher.xtext.openCypher.Merge;
import io.codekontor.opencypher.xtext.openCypher.MergeAction;
import io.codekontor.opencypher.xtext.openCypher.MultiPartQuery;
import io.codekontor.opencypher.xtext.openCypher.MultiPartSubQuery;
import io.codekontor.opencypher.xtext.openCypher.MultiplyDivideModuloExpression;
import io.codekontor.opencypher.xtext.openCypher.NULL;
import io.codekontor.opencypher.xtext.openCypher.NodeLabel;
import io.codekontor.opencypher.xtext.openCypher.NodeLabelsExpression;
import io.codekontor.opencypher.xtext.openCypher.NodePattern;
import io.codekontor.opencypher.xtext.openCypher.NodePropertyExistenceConstraint;
import io.codekontor.opencypher.xtext.openCypher.None;
import io.codekontor.opencypher.xtext.openCypher.NotExpression;
import io.codekontor.opencypher.xtext.openCypher.NumberLiteral;
import io.codekontor.opencypher.xtext.openCypher.OpenCypherPackage;
import io.codekontor.opencypher.xtext.openCypher.OrExpression;
import io.codekontor.opencypher.xtext.openCypher.Order;
import io.codekontor.opencypher.xtext.openCypher.ParenthesizedExpression;
import io.codekontor.opencypher.xtext.openCypher.Pattern;
import io.codekontor.opencypher.xtext.openCypher.PatternComprehension;
import io.codekontor.opencypher.xtext.openCypher.PatternElement;
import io.codekontor.opencypher.xtext.openCypher.PatternElementChain;
import io.codekontor.opencypher.xtext.openCypher.PatternPart;
import io.codekontor.opencypher.xtext.openCypher.PeriodicCommitHint;
import io.codekontor.opencypher.xtext.openCypher.PowerOfExpression;
import io.codekontor.opencypher.xtext.openCypher.ProcedureName;
import io.codekontor.opencypher.xtext.openCypher.PropertyLookup;
import io.codekontor.opencypher.xtext.openCypher.PropertyLookupExpression;
import io.codekontor.opencypher.xtext.openCypher.RangeLiteral;
import io.codekontor.opencypher.xtext.openCypher.Reduce;
import io.codekontor.opencypher.xtext.openCypher.RegExpMatchingExpression;
import io.codekontor.opencypher.xtext.openCypher.RelationshipDetail;
import io.codekontor.opencypher.xtext.openCypher.RelationshipPattern;
import io.codekontor.opencypher.xtext.openCypher.RelationshipPatternSyntax;
import io.codekontor.opencypher.xtext.openCypher.RelationshipPropertyExistenceConstraint;
import io.codekontor.opencypher.xtext.openCypher.RelationshipsPattern;
import io.codekontor.opencypher.xtext.openCypher.Remove;
import io.codekontor.opencypher.xtext.openCypher.RemoveItemLabel;
import io.codekontor.opencypher.xtext.openCypher.RemoveItemProperty;
import io.codekontor.opencypher.xtext.openCypher.Return;
import io.codekontor.opencypher.xtext.openCypher.ReturnBody;
import io.codekontor.opencypher.xtext.openCypher.ReturnItem;
import io.codekontor.opencypher.xtext.openCypher.ReturnItems;
import io.codekontor.opencypher.xtext.openCypher.ScanHint;
import io.codekontor.opencypher.xtext.openCypher.SetItem;
import io.codekontor.opencypher.xtext.openCypher.ShortestPath;
import io.codekontor.opencypher.xtext.openCypher.Single;
import io.codekontor.opencypher.xtext.openCypher.SinglePartQuery;
import io.codekontor.opencypher.xtext.openCypher.Skip;
import io.codekontor.opencypher.xtext.openCypher.SortItem;
import io.codekontor.opencypher.xtext.openCypher.StandaloneCall;
import io.codekontor.opencypher.xtext.openCypher.Start;
import io.codekontor.opencypher.xtext.openCypher.StartPoint;
import io.codekontor.opencypher.xtext.openCypher.StartsWithExpression;
import io.codekontor.opencypher.xtext.openCypher.StringListNullOperatorExpression;
import io.codekontor.opencypher.xtext.openCypher.StringLiteral;
import io.codekontor.opencypher.xtext.openCypher.UnaryAddOrSubtractExpression;
import io.codekontor.opencypher.xtext.openCypher.Union;
import io.codekontor.opencypher.xtext.openCypher.UniqueConstraint;
import io.codekontor.opencypher.xtext.openCypher.Unwind;
import io.codekontor.opencypher.xtext.openCypher.VariableDeclaration;
import io.codekontor.opencypher.xtext.openCypher.VariableRef;
import io.codekontor.opencypher.xtext.openCypher.VersionNumber;
import io.codekontor.opencypher.xtext.openCypher.Where;
import io.codekontor.opencypher.xtext.openCypher.With;
import io.codekontor.opencypher.xtext.openCypher.XorExpression;
import io.codekontor.opencypher.xtext.openCypher.YieldItem;
import io.codekontor.opencypher.xtext.openCypher.YieldItems;
import io.codekontor.opencypher.xtext.services.OpenCypherGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OpenCypherSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenCypherGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenCypherPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenCypherPackage.ADD_OR_SUBTRACT_EXPRESSION:
				sequence_AddOrSubtractExpression(context, (AddOrSubtractExpression) semanticObject); 
				return; 
			case OpenCypherPackage.ALL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (All) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (All) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.ALL_OPTIONS:
				sequence_QueryOptions(context, (AllOptions) semanticObject); 
				return; 
			case OpenCypherPackage.ALL_SHORTEST_PATHS:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_ShortestPathPattern(context, (AllShortestPaths) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternPartRule()
						|| rule == grammarAccess.getAnonymousPatternPartRule()
						|| rule == grammarAccess.getShortestPathPatternRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_ShortestPathPattern(context, (AllShortestPaths) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case OpenCypherPackage.ANY:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Any) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Any) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.BOOLEAN_LITERAL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getBooleanLiteralRule()) {
					sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_BooleanLiteral_PropertyExpression(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.BULK_IMPORT_QUERY:
				sequence_BulkImportQuery(context, (BulkImportQuery) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_ALTERNATIVES:
				sequence_CaseAlternatives(context, (CaseAlternatives) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getCaseExpressionRule()) {
					sequence_CaseExpression(context, (CaseExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_CaseExpression_PropertyExpression(context, (CaseExpression) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.COMBINED_QUERY:
				sequence_RegularQuery(context, (CombinedQuery) semanticObject); 
				return; 
			case OpenCypherPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case OpenCypherPackage.CONFIGURATION_OPTION:
				sequence_ConfigurationOption(context, (ConfigurationOption) semanticObject); 
				return; 
			case OpenCypherPackage.CONTAINS_EXPRESSION:
				sequence_StringOperatorExpression(context, (ContainsExpression) semanticObject); 
				return; 
			case OpenCypherPackage.COUNT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Count) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Count) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case OpenCypherPackage.CREATE_INDEX:
				sequence_CreateIndex(context, (CreateIndex) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER:
				sequence_Cypher(context, (Cypher) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER_OPTION:
				sequence_CypherOption(context, (CypherOption) semanticObject); 
				return; 
			case OpenCypherPackage.DECIMAL_INTEGER:
				sequence_DecimalInteger(context, (DecimalInteger) semanticObject); 
				return; 
			case OpenCypherPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_INDEX:
				sequence_DropIndex(context, (DropIndex) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropNodePropertyExistenceConstraint(context, (DropNodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropRelationshipPropertyExistenceConstraint(context, (DropRelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_UNIQUE_CONSTRAINT:
				sequence_DropUniqueConstraint(context, (DropUniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.ENDS_WITH_EXPRESSION:
				sequence_StringOperatorExpression(context, (EndsWithExpression) semanticObject); 
				return; 
			case OpenCypherPackage.EXPLICIT_PROCEDURE_INVOCATION:
				sequence_ExplicitProcedureInvocation(context, (ExplicitProcedureInvocation) semanticObject); 
				return; 
			case OpenCypherPackage.EXTRACT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Extract) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Extract) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.FILTER:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Filter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Filter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.FILTER_EXPRESSION:
				sequence_FilterExpression(context, (FilterExpression) semanticObject); 
				return; 
			case OpenCypherPackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case OpenCypherPackage.FUNCTION_INVOCATION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getFunctionInvocationRule()) {
					sequence_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_FunctionInvocation_PropertyExpression(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.ID_IN_COLL:
				sequence_IdInColl(context, (IdInColl) semanticObject); 
				return; 
			case OpenCypherPackage.ID_LOOKUP:
				sequence_IdLookup(context, (IdLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IDENTIFIED_INDEX_LOOKUP:
				sequence_IdentifiedIndexLookup(context, (IdentifiedIndexLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IMPLICIT_PROCEDURE_INVOCATION:
				sequence_ImplicitProcedureInvocation(context, (ImplicitProcedureInvocation) semanticObject); 
				return; 
			case OpenCypherPackage.IN_COLLECTION_EXPRESSION:
				sequence_StringOperatorExpression(context, (InCollectionExpression) semanticObject); 
				return; 
			case OpenCypherPackage.IN_QUERY_CALL:
				sequence_InQueryCall(context, (InQueryCall) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_HINT:
				sequence_Hint(context, (IndexHint) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_LOOKUP_EXPRESSION:
				sequence_ListOperatorExpression(context, (IndexLookupExpression) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_QUERY:
				sequence_IndexQuery(context, (IndexQuery) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_RANGE_EXPRESSION:
				sequence_ListOperatorExpression(context, (IndexRangeExpression) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NOT_NULL_EXPRESSION:
				sequence_NullOperatorExpression(context, (IsNotNullExpression) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NULL_EXPRESSION:
				sequence_NullOperatorExpression(context, (IsNullExpression) semanticObject); 
				return; 
			case OpenCypherPackage.JOIN_HINT:
				sequence_Hint(context, (JoinHint) semanticObject); 
				return; 
			case OpenCypherPackage.LEGACY_PARAMETER:
				if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLegacyParameterRule()) {
					sequence_LegacyParameter(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_LegacyParameter_PropertyExpression(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case OpenCypherPackage.LIST_COMPREHENSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getListComprehensionRule()) {
					sequence_ListComprehension(context, (ListComprehension) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_ListComprehension_PropertyExpression(context, (ListComprehension) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.LIST_LITERAL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getListLiteralRule()) {
					sequence_ListLiteral(context, (ListLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_ListLiteral_PropertyExpression(context, (ListLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.LITERAL_IDS:
				sequence_LiteralIds(context, (LiteralIds) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV:
				sequence_LoadCSV(context, (LoadCSV) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV_QUERY:
				sequence_LoadCSVQuery(context, (LoadCSVQuery) semanticObject); 
				return; 
			case OpenCypherPackage.MAP_LITERAL:
				if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getMapLiteralRule()) {
					sequence_MapLiteral(context, (MapLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_MapLiteral_PropertyExpression(context, (MapLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.MAP_LITERAL_ENTRY:
				sequence_MapLiteralEntry(context, (MapLiteralEntry) semanticObject); 
				return; 
			case OpenCypherPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE_ACTION:
				sequence_MergeAction(context, (MergeAction) semanticObject); 
				return; 
			case OpenCypherPackage.MULTI_PART_QUERY:
				sequence_MultiPartQuery(context, (MultiPartQuery) semanticObject); 
				return; 
			case OpenCypherPackage.MULTI_PART_SUB_QUERY:
				sequence_MultiPartSubQuery(context, (MultiPartSubQuery) semanticObject); 
				return; 
			case OpenCypherPackage.MULTIPLY_DIVIDE_MODULO_EXPRESSION:
				sequence_MultiplyDivideModuloExpression(context, (MultiplyDivideModuloExpression) semanticObject); 
				return; 
			case OpenCypherPackage.NULL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (NULL) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Literal_PropertyExpression(context, (NULL) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.NODE_LABEL:
				sequence_NodeLabel(context, (NodeLabel) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_LABELS_EXPRESSION:
				sequence_NodeLabels_PropertyOrLabelsExpression(context, (NodeLabelsExpression) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PATTERN:
				sequence_NodeLabels_NodePattern(context, (NodePattern) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_NodePropertyExistenceConstraint(context, (NodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.NONE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (None) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (None) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case OpenCypherPackage.NUMBER_LITERAL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getNumberLiteralRule()) {
					sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_NumberLiteral_PropertyExpression(context, (NumberLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case OpenCypherPackage.ORDER:
				sequence_Order(context, (Order) semanticObject); 
				return; 
			case OpenCypherPackage.PARAMETER:
				if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getParameterRule()) {
					sequence_Parameter(context, (io.codekontor.opencypher.xtext.openCypher.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Parameter_PropertyExpression(context, (io.codekontor.opencypher.xtext.openCypher.Parameter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.PARENTHESIZED_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()) {
					sequence_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_ParenthesizedExpression_PropertyExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_COMPREHENSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getPatternComprehensionRule()) {
					sequence_PatternComprehension(context, (PatternComprehension) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PatternComprehension_PropertyExpression(context, (PatternComprehension) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.PATTERN_ELEMENT:
				sequence_PatternElement(context, (PatternElement) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_ELEMENT_CHAIN:
				sequence_PatternElementChain(context, (PatternElementChain) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_PART:
				sequence_PatternPart(context, (PatternPart) semanticObject); 
				return; 
			case OpenCypherPackage.PERIODIC_COMMIT_HINT:
				sequence_PeriodicCommitHint(context, (PeriodicCommitHint) semanticObject); 
				return; 
			case OpenCypherPackage.POWER_OF_EXPRESSION:
				sequence_PowerOfExpression(context, (PowerOfExpression) semanticObject); 
				return; 
			case OpenCypherPackage.PROCEDURE_NAME:
				sequence_ProcedureName(context, (ProcedureName) semanticObject); 
				return; 
			case OpenCypherPackage.PROPERTY_LOOKUP:
				sequence_PropertyLookup(context, (PropertyLookup) semanticObject); 
				return; 
			case OpenCypherPackage.PROPERTY_LOOKUP_EXPRESSION:
				sequence_PropertyOrLabelsExpression(context, (PropertyLookupExpression) semanticObject); 
				return; 
			case OpenCypherPackage.RANGE_LITERAL:
				sequence_RangeLiteral(context, (RangeLiteral) semanticObject); 
				return; 
			case OpenCypherPackage.REDUCE:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getReduceRule()) {
					sequence_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.REG_EXP_MATCHING_EXPRESSION:
				sequence_StringOperatorExpression(context, (RegExpMatchingExpression) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_DETAIL:
				sequence_RelationshipDetail_RelationshipTypes(context, (RelationshipDetail) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN:
				sequence_RelationshipPattern(context, (RelationshipPattern) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN_SYNTAX:
				sequence_RelationshipPatternSyntax(context, (RelationshipPatternSyntax) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_RelationshipPropertyExistenceConstraint(context, (RelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIPS_PATTERN:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getRelationshipsPatternRule()) {
					sequence_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE_ITEM_LABEL:
				sequence_NodeLabels_RemoveItem(context, (RemoveItemLabel) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE_ITEM_PROPERTY:
				sequence_RemoveItem(context, (RemoveItemProperty) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_BODY:
				sequence_ReturnBody(context, (ReturnBody) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEM:
				sequence_ReturnItem(context, (ReturnItem) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEMS:
				sequence_ReturnItems(context, (ReturnItems) semanticObject); 
				return; 
			case OpenCypherPackage.SCAN_HINT:
				sequence_Hint(context, (ScanHint) semanticObject); 
				return; 
			case OpenCypherPackage.SET:
				sequence_Set(context, (io.codekontor.opencypher.xtext.openCypher.Set) semanticObject); 
				return; 
			case OpenCypherPackage.SET_ITEM:
				sequence_NodeLabels_SetItem(context, (SetItem) semanticObject); 
				return; 
			case OpenCypherPackage.SHORTEST_PATH:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternPartRule()
						|| rule == grammarAccess.getAnonymousPatternPartRule()
						|| rule == grammarAccess.getShortestPathPatternRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.SINGLE:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Single) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Single) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.SINGLE_PART_QUERY:
				sequence_SinglePartQuery(context, (SinglePartQuery) semanticObject); 
				return; 
			case OpenCypherPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case OpenCypherPackage.SORT_ITEM:
				sequence_SortItem(context, (SortItem) semanticObject); 
				return; 
			case OpenCypherPackage.STANDALONE_CALL:
				sequence_StandaloneCall(context, (StandaloneCall) semanticObject); 
				return; 
			case OpenCypherPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case OpenCypherPackage.START_POINT:
				sequence_StartPoint(context, (StartPoint) semanticObject); 
				return; 
			case OpenCypherPackage.STARTS_WITH_EXPRESSION:
				sequence_StringOperatorExpression(context, (StartsWithExpression) semanticObject); 
				return; 
			case OpenCypherPackage.STRING_LIST_NULL_OPERATOR_EXPRESSION:
				sequence_StringListNullOperatorExpression(context, (StringListNullOperatorExpression) semanticObject); 
				return; 
			case OpenCypherPackage.STRING_LITERAL:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getStringLiteralRule()) {
					sequence_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.UNARY_ADD_OR_SUBTRACT_EXPRESSION:
				sequence_UnaryAddOrSubtractExpression(context, (UnaryAddOrSubtractExpression) semanticObject); 
				return; 
			case OpenCypherPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case OpenCypherPackage.UNIQUE_CONSTRAINT:
				sequence_UniqueConstraint(context, (UniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.UNWIND:
				sequence_Unwind(context, (Unwind) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE_REF:
				if (rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrLabelsExpressionRule()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getPropertyLookupExpressionLeftAction_1_0()
						|| action == grammarAccess.getPropertyOrLabelsExpressionAccess().getNodeLabelsExpressionLeftAction_2_0()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (VariableRef) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.VERSION_NUMBER:
				sequence_VersionNumber(context, (VersionNumber) semanticObject); 
				return; 
			case OpenCypherPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			case OpenCypherPackage.WITH:
				sequence_With(context, (With) semanticObject); 
				return; 
			case OpenCypherPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			case OpenCypherPackage.YIELD_ITEM:
				sequence_YieldItem(context, (YieldItem) semanticObject); 
				return; 
			case OpenCypherPackage.YIELD_ITEMS:
				sequence_YieldItems(context, (YieldItems) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddOrSubtractExpression
	 *     OrExpression returns AddOrSubtractExpression
	 *     OrExpression.OrExpression_1_0 returns AddOrSubtractExpression
	 *     XorExpression returns AddOrSubtractExpression
	 *     XorExpression.XorExpression_1_0 returns AddOrSubtractExpression
	 *     AndExpression returns AddOrSubtractExpression
	 *     AndExpression.AndExpression_1_0 returns AddOrSubtractExpression
	 *     NotExpression returns AddOrSubtractExpression
	 *     ComparisonExpression returns AddOrSubtractExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AddOrSubtractExpression
	 *     AddOrSubtractExpression returns AddOrSubtractExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns AddOrSubtractExpression
	 *
	 * Constraint:
	 *     (left=AddOrSubtractExpression_AddOrSubtractExpression_1_0 (operator='+' | operator='-') right=MultiplyDivideModuloExpression)
	 */
	protected void sequence_AddOrSubtractExpression(ISerializationContext context, AddOrSubtractExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     XorExpression returns AndExpression
	 *     XorExpression.XorExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 operator='AND' right=NotExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOperatorANDKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightNotExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns All
	 *     OrExpression returns All
	 *     OrExpression.OrExpression_1_0 returns All
	 *     XorExpression returns All
	 *     XorExpression.XorExpression_1_0 returns All
	 *     AndExpression returns All
	 *     AndExpression.AndExpression_1_0 returns All
	 *     NotExpression returns All
	 *     ComparisonExpression returns All
	 *     ComparisonExpression.ComparisonExpression_1_0 returns All
	 *     AddOrSubtractExpression returns All
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns All
	 *     MultiplyDivideModuloExpression returns All
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns All
	 *     PowerOfExpression returns All
	 *     PowerOfExpression.PowerOfExpression_1_0 returns All
	 *     UnaryAddOrSubtractExpression returns All
	 *     StringListNullOperatorExpression returns All
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns All
	 *     PropertyOrLabelsExpression returns All
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns All
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns All
	 *     Atom returns All
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, All semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_10_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Any
	 *     OrExpression returns Any
	 *     OrExpression.OrExpression_1_0 returns Any
	 *     XorExpression returns Any
	 *     XorExpression.XorExpression_1_0 returns Any
	 *     AndExpression returns Any
	 *     AndExpression.AndExpression_1_0 returns Any
	 *     NotExpression returns Any
	 *     ComparisonExpression returns Any
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Any
	 *     AddOrSubtractExpression returns Any
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Any
	 *     MultiplyDivideModuloExpression returns Any
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Any
	 *     PowerOfExpression returns Any
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Any
	 *     UnaryAddOrSubtractExpression returns Any
	 *     StringListNullOperatorExpression returns Any
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Any
	 *     PropertyOrLabelsExpression returns Any
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Any
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Any
	 *     Atom returns Any
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Any semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_11_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Count
	 *     OrExpression returns Count
	 *     OrExpression.OrExpression_1_0 returns Count
	 *     XorExpression returns Count
	 *     XorExpression.XorExpression_1_0 returns Count
	 *     AndExpression returns Count
	 *     AndExpression.AndExpression_1_0 returns Count
	 *     NotExpression returns Count
	 *     ComparisonExpression returns Count
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Count
	 *     AddOrSubtractExpression returns Count
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Count
	 *     MultiplyDivideModuloExpression returns Count
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Count
	 *     PowerOfExpression returns Count
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Count
	 *     UnaryAddOrSubtractExpression returns Count
	 *     StringListNullOperatorExpression returns Count
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Count
	 *     PropertyOrLabelsExpression returns Count
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Count
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Count
	 *     Atom returns Count
	 *
	 * Constraint:
	 *     {Count}
	 */
	protected void sequence_Atom(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Extract
	 *     OrExpression returns Extract
	 *     OrExpression.OrExpression_1_0 returns Extract
	 *     XorExpression returns Extract
	 *     XorExpression.XorExpression_1_0 returns Extract
	 *     AndExpression returns Extract
	 *     AndExpression.AndExpression_1_0 returns Extract
	 *     NotExpression returns Extract
	 *     ComparisonExpression returns Extract
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Extract
	 *     AddOrSubtractExpression returns Extract
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Extract
	 *     MultiplyDivideModuloExpression returns Extract
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Extract
	 *     PowerOfExpression returns Extract
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Extract
	 *     UnaryAddOrSubtractExpression returns Extract
	 *     StringListNullOperatorExpression returns Extract
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Extract
	 *     PropertyOrLabelsExpression returns Extract
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Extract
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Extract
	 *     Atom returns Extract
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression?)
	 */
	protected void sequence_Atom(ISerializationContext context, Extract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Filter
	 *     OrExpression returns Filter
	 *     OrExpression.OrExpression_1_0 returns Filter
	 *     XorExpression returns Filter
	 *     XorExpression.XorExpression_1_0 returns Filter
	 *     AndExpression returns Filter
	 *     AndExpression.AndExpression_1_0 returns Filter
	 *     NotExpression returns Filter
	 *     ComparisonExpression returns Filter
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Filter
	 *     AddOrSubtractExpression returns Filter
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Filter
	 *     MultiplyDivideModuloExpression returns Filter
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Filter
	 *     PowerOfExpression returns Filter
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Filter
	 *     UnaryAddOrSubtractExpression returns Filter
	 *     StringListNullOperatorExpression returns Filter
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Filter
	 *     PropertyOrLabelsExpression returns Filter
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Filter
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Filter
	 *     Atom returns Filter
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.FILTER__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.FILTER__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_7_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns None
	 *     OrExpression returns None
	 *     OrExpression.OrExpression_1_0 returns None
	 *     XorExpression returns None
	 *     XorExpression.XorExpression_1_0 returns None
	 *     AndExpression returns None
	 *     AndExpression.AndExpression_1_0 returns None
	 *     NotExpression returns None
	 *     ComparisonExpression returns None
	 *     ComparisonExpression.ComparisonExpression_1_0 returns None
	 *     AddOrSubtractExpression returns None
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns None
	 *     MultiplyDivideModuloExpression returns None
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns None
	 *     PowerOfExpression returns None
	 *     PowerOfExpression.PowerOfExpression_1_0 returns None
	 *     UnaryAddOrSubtractExpression returns None
	 *     StringListNullOperatorExpression returns None
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns None
	 *     PropertyOrLabelsExpression returns None
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns None
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns None
	 *     Atom returns None
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, None semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_12_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns All
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, All semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Any
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Count
	 *
	 * Constraint:
	 *     propertyLookups+=PropertyLookup+
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Extract
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Extract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Filter
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns None
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Single
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Single semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns VariableRef
	 *
	 * Constraint:
	 *     (variableRef=[VariableDeclaration|SYMBOLIC_NAME_X] propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Single
	 *     OrExpression returns Single
	 *     OrExpression.OrExpression_1_0 returns Single
	 *     XorExpression returns Single
	 *     XorExpression.XorExpression_1_0 returns Single
	 *     AndExpression returns Single
	 *     AndExpression.AndExpression_1_0 returns Single
	 *     NotExpression returns Single
	 *     ComparisonExpression returns Single
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Single
	 *     AddOrSubtractExpression returns Single
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Single
	 *     MultiplyDivideModuloExpression returns Single
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Single
	 *     PowerOfExpression returns Single
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Single
	 *     UnaryAddOrSubtractExpression returns Single
	 *     StringListNullOperatorExpression returns Single
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Single
	 *     PropertyOrLabelsExpression returns Single
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Single
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Single
	 *     Atom returns Single
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Single semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_13_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     OrExpression returns VariableRef
	 *     OrExpression.OrExpression_1_0 returns VariableRef
	 *     XorExpression returns VariableRef
	 *     XorExpression.XorExpression_1_0 returns VariableRef
	 *     AndExpression returns VariableRef
	 *     AndExpression.AndExpression_1_0 returns VariableRef
	 *     NotExpression returns VariableRef
	 *     ComparisonExpression returns VariableRef
	 *     ComparisonExpression.ComparisonExpression_1_0 returns VariableRef
	 *     AddOrSubtractExpression returns VariableRef
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns VariableRef
	 *     MultiplyDivideModuloExpression returns VariableRef
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns VariableRef
	 *     PowerOfExpression returns VariableRef
	 *     PowerOfExpression.PowerOfExpression_1_0 returns VariableRef
	 *     UnaryAddOrSubtractExpression returns VariableRef
	 *     StringListNullOperatorExpression returns VariableRef
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns VariableRef
	 *     PropertyOrLabelsExpression returns VariableRef
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns VariableRef
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns VariableRef
	 *     Atom returns VariableRef
	 *
	 * Constraint:
	 *     variableRef=[VariableDeclaration|SYMBOLIC_NAME_X]
	 */
	protected void sequence_Atom(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getVariableRefVariableDeclarationSYMBOLIC_NAME_XParserRuleCall_18_1_0_1(), semanticObject.eGet(OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.OrExpression_1_0 returns BooleanLiteral
	 *     XorExpression returns BooleanLiteral
	 *     XorExpression.XorExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.AndExpression_1_0 returns BooleanLiteral
	 *     NotExpression returns BooleanLiteral
	 *     ComparisonExpression returns BooleanLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BooleanLiteral
	 *     AddOrSubtractExpression returns BooleanLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns BooleanLiteral
	 *     MultiplyDivideModuloExpression returns BooleanLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns BooleanLiteral
	 *     PowerOfExpression returns BooleanLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns BooleanLiteral
	 *     UnaryAddOrSubtractExpression returns BooleanLiteral
	 *     StringListNullOperatorExpression returns BooleanLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns BooleanLiteral
	 *     PropertyOrLabelsExpression returns BooleanLiteral
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns BooleanLiteral
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns BooleanLiteral
	 *     Atom returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     ((value='TRUE' | value='FALSE') propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_BooleanLiteral_PropertyExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BulkImportQuery
	 *     Query returns BulkImportQuery
	 *     BulkImportQuery returns BulkImportQuery
	 *
	 * Constraint:
	 *     (periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery)
	 */
	protected void sequence_BulkImportQuery(ISerializationContext context, BulkImportQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0(), semanticObject.getPeriodicCommitHint());
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getLoadCSVQueryLoadCSVQueryParserRuleCall_1_0(), semanticObject.getLoadCSVQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseAlternatives returns CaseAlternatives
	 *
	 * Constraint:
	 *     (when=Expression then=Expression)
	 */
	protected void sequence_CaseAlternatives(ISerializationContext context, CaseAlternatives semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getWhenExpressionParserRuleCall_1_0(), semanticObject.getWhen());
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getThenExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CaseExpression
	 *     OrExpression returns CaseExpression
	 *     OrExpression.OrExpression_1_0 returns CaseExpression
	 *     XorExpression returns CaseExpression
	 *     XorExpression.XorExpression_1_0 returns CaseExpression
	 *     AndExpression returns CaseExpression
	 *     AndExpression.AndExpression_1_0 returns CaseExpression
	 *     NotExpression returns CaseExpression
	 *     ComparisonExpression returns CaseExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns CaseExpression
	 *     AddOrSubtractExpression returns CaseExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns CaseExpression
	 *     MultiplyDivideModuloExpression returns CaseExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns CaseExpression
	 *     PowerOfExpression returns CaseExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns CaseExpression
	 *     UnaryAddOrSubtractExpression returns CaseExpression
	 *     StringListNullOperatorExpression returns CaseExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns CaseExpression
	 *     PropertyOrLabelsExpression returns CaseExpression
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns CaseExpression
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns CaseExpression
	 *     Atom returns CaseExpression
	 *     CaseExpression returns CaseExpression
	 *
	 * Constraint:
	 *     ((caseAlternatives+=CaseAlternatives+ | (caseExpression=Expression caseAlternatives+=CaseAlternatives+)) elseExpression=Expression?)
	 */
	protected void sequence_CaseExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns CaseExpression
	 *
	 * Constraint:
	 *     (
	 *         (caseAlternatives+=CaseAlternatives+ | (caseExpression=Expression caseAlternatives+=CaseAlternatives+)) 
	 *         elseExpression=Expression? 
	 *         propertyLookups+=PropertyLookup+
	 *     )
	 */
	protected void sequence_CaseExpression_PropertyExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     XorExpression returns ComparisonExpression
	 *     XorExpression.XorExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     NotExpression returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *
	 * Constraint:
	 *     (
	 *         left=ComparisonExpression_ComparisonExpression_1_0 
	 *         (
	 *             operator='=' | 
	 *             operator='<>' | 
	 *             operator='<' | 
	 *             operator='>' | 
	 *             operator='<=' | 
	 *             operator='>='
	 *         ) 
	 *         right=AddOrSubtractExpression
	 *     )
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationOption returns ConfigurationOption
	 *
	 * Constraint:
	 *     (key=SYMBOLIC_NAME_X value=SYMBOLIC_NAME_X)
	 */
	protected void sequence_ConfigurationOption(ISerializationContext context, ConfigurationOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getKeySYMBOLIC_NAME_XParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getValueSYMBOLIC_NAME_XParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateIndex
	 *     Command returns CreateIndex
	 *     CreateIndex returns CreateIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_CreateIndex(ISerializationContext context, CreateIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Create
	 *     UpdatingClause returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (uniqueContraint?='UNIQUE'? pattern=Pattern)
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CypherOption returns CypherOption
	 *
	 * Constraint:
	 *     (versionNumber=VersionNumber? configurationOption+=ConfigurationOption*)
	 */
	protected void sequence_CypherOption(ISerializationContext context, CypherOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cypher returns Cypher
	 *
	 * Constraint:
	 *     (queryOptions=QueryOptions statements+=Statement*)
	 */
	protected void sequence_Cypher(ISerializationContext context, Cypher semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DecimalInteger returns DecimalInteger
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_DecimalInteger(ISerializationContext context, DecimalInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalIntegerAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Delete
	 *     UpdatingClause returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (detach?='DETACH'? expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropIndex
	 *     Command returns DropIndex
	 *     DropIndex returns DropIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_DropIndex(ISerializationContext context, DropIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropNodePropertyExistenceConstraint
	 *     Command returns DropNodePropertyExistenceConstraint
	 *     DropNodePropertyExistenceConstraint returns DropNodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     nodePropertyExistenceConstraint=NodePropertyExistenceConstraint
	 */
	protected void sequence_DropNodePropertyExistenceConstraint(ISerializationContext context, DropNodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropNodePropertyExistenceConstraintAccess().getNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getNodePropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropRelationshipPropertyExistenceConstraint
	 *     Command returns DropRelationshipPropertyExistenceConstraint
	 *     DropRelationshipPropertyExistenceConstraint returns DropRelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint
	 */
	protected void sequence_DropRelationshipPropertyExistenceConstraint(ISerializationContext context, DropRelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropRelationshipPropertyExistenceConstraintAccess().getRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getRelationshipPropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropUniqueConstraint
	 *     Command returns DropUniqueConstraint
	 *     DropUniqueConstraint returns DropUniqueConstraint
	 *
	 * Constraint:
	 *     uniqueConstraint=UniqueConstraint
	 */
	protected void sequence_DropUniqueConstraint(ISerializationContext context, DropUniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropUniqueConstraintAccess().getUniqueConstraintUniqueConstraintParserRuleCall_1_0(), semanticObject.getUniqueConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExplicitProcedureInvocation returns ExplicitProcedureInvocation
	 *
	 * Constraint:
	 *     (procedureName=ProcedureName (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_ExplicitProcedureInvocation(ISerializationContext context, ExplicitProcedureInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FilterExpression returns FilterExpression
	 *
	 * Constraint:
	 *     (idInColl=IdInColl where=Where?)
	 */
	protected void sequence_FilterExpression(ISerializationContext context, FilterExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Foreach
	 *     UpdatingClause returns Foreach
	 *     Foreach returns Foreach
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression updatingClauses+=UpdatingClause+)
	 */
	protected void sequence_Foreach(ISerializationContext context, Foreach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionInvocation
	 *     OrExpression returns FunctionInvocation
	 *     OrExpression.OrExpression_1_0 returns FunctionInvocation
	 *     XorExpression returns FunctionInvocation
	 *     XorExpression.XorExpression_1_0 returns FunctionInvocation
	 *     AndExpression returns FunctionInvocation
	 *     AndExpression.AndExpression_1_0 returns FunctionInvocation
	 *     NotExpression returns FunctionInvocation
	 *     ComparisonExpression returns FunctionInvocation
	 *     ComparisonExpression.ComparisonExpression_1_0 returns FunctionInvocation
	 *     AddOrSubtractExpression returns FunctionInvocation
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns FunctionInvocation
	 *     MultiplyDivideModuloExpression returns FunctionInvocation
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns FunctionInvocation
	 *     PowerOfExpression returns FunctionInvocation
	 *     PowerOfExpression.PowerOfExpression_1_0 returns FunctionInvocation
	 *     UnaryAddOrSubtractExpression returns FunctionInvocation
	 *     StringListNullOperatorExpression returns FunctionInvocation
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns FunctionInvocation
	 *     PropertyOrLabelsExpression returns FunctionInvocation
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns FunctionInvocation
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns FunctionInvocation
	 *     Atom returns FunctionInvocation
	 *     FunctionInvocation returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_FunctionInvocation_PropertyExpression(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns IndexHint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Hint(ISerializationContext context, IndexHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableDeclarationParserRuleCall_0_5_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_0_6_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getHintAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns JoinHint
	 *
	 * Constraint:
	 *     (variables+=VariableDeclaration variables+=VariableDeclaration*)
	 */
	protected void sequence_Hint(ISerializationContext context, JoinHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns ScanHint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel)
	 */
	protected void sequence_Hint(ISerializationContext context, ScanHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableDeclarationParserRuleCall_2_1_4_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_2_1_5_0(), semanticObject.getNodeLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdInColl returns IdInColl
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression)
	 */
	protected void sequence_IdInColl(ISerializationContext context, IdInColl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdInCollAccess().getVariableVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIdInCollAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdLookup
	 *     NodeLookup returns IdLookup
	 *     RelationshipLookup returns IdLookup
	 *     IdLookup returns IdLookup
	 *
	 * Constraint:
	 *     (ids=LiteralIds | legacyParameter=Parameter | wildcard='*')
	 */
	protected void sequence_IdLookup(ISerializationContext context, IdLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdentifiedIndexLookup
	 *     NodeLookup returns IdentifiedIndexLookup
	 *     RelationshipLookup returns IdentifiedIndexLookup
	 *     IdentifiedIndexLookup returns IdentifiedIndexLookup
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME_X key=SYMBOLIC_NAME_X (value=STRING_LITERAL | legacyParameter=LegacyParameter))
	 */
	protected void sequence_IdentifiedIndexLookup(ISerializationContext context, IdentifiedIndexLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicitProcedureInvocation returns ImplicitProcedureInvocation
	 *
	 * Constraint:
	 *     procedureName=ProcedureName
	 */
	protected void sequence_ImplicitProcedureInvocation(ISerializationContext context, ImplicitProcedureInvocation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IMPLICIT_PROCEDURE_INVOCATION__PROCEDURE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IMPLICIT_PROCEDURE_INVOCATION__PROCEDURE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplicitProcedureInvocationAccess().getProcedureNameProcedureNameParserRuleCall_1_0(), semanticObject.getProcedureName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns InQueryCall
	 *     ReadingClause returns InQueryCall
	 *     InQueryCall returns InQueryCall
	 *
	 * Constraint:
	 *     (invocation=ExplicitProcedureInvocation yieldItems=YieldItems?)
	 */
	protected void sequence_InQueryCall(ISerializationContext context, InQueryCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IndexQuery
	 *     NodeLookup returns IndexQuery
	 *     RelationshipLookup returns IndexQuery
	 *     IndexQuery returns IndexQuery
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME_X (query=STRING_LITERAL | parameter=Parameter))
	 */
	protected void sequence_IndexQuery(ISerializationContext context, IndexQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Index returns Index
	 *
	 * Constraint:
	 *     (nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexAccess().getNodeLabelNodeLabelParserRuleCall_2_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getIndexAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_4_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns LegacyParameter
	 *     Expression returns LegacyParameter
	 *     OrExpression returns LegacyParameter
	 *     OrExpression.OrExpression_1_0 returns LegacyParameter
	 *     XorExpression returns LegacyParameter
	 *     XorExpression.XorExpression_1_0 returns LegacyParameter
	 *     AndExpression returns LegacyParameter
	 *     AndExpression.AndExpression_1_0 returns LegacyParameter
	 *     NotExpression returns LegacyParameter
	 *     ComparisonExpression returns LegacyParameter
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LegacyParameter
	 *     AddOrSubtractExpression returns LegacyParameter
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns LegacyParameter
	 *     MultiplyDivideModuloExpression returns LegacyParameter
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns LegacyParameter
	 *     PowerOfExpression returns LegacyParameter
	 *     PowerOfExpression.PowerOfExpression_1_0 returns LegacyParameter
	 *     UnaryAddOrSubtractExpression returns LegacyParameter
	 *     StringListNullOperatorExpression returns LegacyParameter
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns LegacyParameter
	 *     PropertyOrLabelsExpression returns LegacyParameter
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns LegacyParameter
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns LegacyParameter
	 *     Atom returns LegacyParameter
	 *     LegacyParameter returns LegacyParameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME_X | parameter=Number)
	 */
	protected void sequence_LegacyParameter(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns LegacyParameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME_X | parameter=Number) propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_LegacyParameter_PropertyExpression(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     limit=Expression
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLimitAccess().getLimitExpressionParserRuleCall_1_0(), semanticObject.getLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListComprehension
	 *     OrExpression returns ListComprehension
	 *     OrExpression.OrExpression_1_0 returns ListComprehension
	 *     XorExpression returns ListComprehension
	 *     XorExpression.XorExpression_1_0 returns ListComprehension
	 *     AndExpression returns ListComprehension
	 *     AndExpression.AndExpression_1_0 returns ListComprehension
	 *     NotExpression returns ListComprehension
	 *     ComparisonExpression returns ListComprehension
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ListComprehension
	 *     AddOrSubtractExpression returns ListComprehension
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns ListComprehension
	 *     MultiplyDivideModuloExpression returns ListComprehension
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns ListComprehension
	 *     PowerOfExpression returns ListComprehension
	 *     PowerOfExpression.PowerOfExpression_1_0 returns ListComprehension
	 *     UnaryAddOrSubtractExpression returns ListComprehension
	 *     StringListNullOperatorExpression returns ListComprehension
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns ListComprehension
	 *     PropertyOrLabelsExpression returns ListComprehension
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns ListComprehension
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns ListComprehension
	 *     Atom returns ListComprehension
	 *     ListComprehension returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression?)
	 */
	protected void sequence_ListComprehension(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ListComprehension_PropertyExpression(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListLiteral
	 *     OrExpression returns ListLiteral
	 *     OrExpression.OrExpression_1_0 returns ListLiteral
	 *     XorExpression returns ListLiteral
	 *     XorExpression.XorExpression_1_0 returns ListLiteral
	 *     AndExpression returns ListLiteral
	 *     AndExpression.AndExpression_1_0 returns ListLiteral
	 *     NotExpression returns ListLiteral
	 *     ComparisonExpression returns ListLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ListLiteral
	 *     AddOrSubtractExpression returns ListLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns ListLiteral
	 *     MultiplyDivideModuloExpression returns ListLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns ListLiteral
	 *     PowerOfExpression returns ListLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns ListLiteral
	 *     UnaryAddOrSubtractExpression returns ListLiteral
	 *     StringListNullOperatorExpression returns ListLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns ListLiteral
	 *     PropertyOrLabelsExpression returns ListLiteral
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns ListLiteral
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns ListLiteral
	 *     Atom returns ListLiteral
	 *     Literal returns ListLiteral
	 *     ListLiteral returns ListLiteral
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)?
	 */
	protected void sequence_ListLiteral(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns ListLiteral
	 *
	 * Constraint:
	 *     ((expressions+=Expression expressions+=Expression*)? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ListLiteral_PropertyExpression(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListOperatorExpression returns IndexLookupExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ListOperatorExpression(ISerializationContext context, IndexLookupExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_LOOKUP_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_LOOKUP_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListOperatorExpressionAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListOperatorExpression returns IndexRangeExpression
	 *
	 * Constraint:
	 *     (lower=Expression? upper=Expression?)
	 */
	protected void sequence_ListOperatorExpression(ISerializationContext context, IndexRangeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralIds returns LiteralIds
	 *
	 * Constraint:
	 *     (ids+=DecimalInteger ids+=DecimalInteger*)
	 */
	protected void sequence_LiteralIds(ISerializationContext context, LiteralIds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NULL
	 *     OrExpression returns NULL
	 *     OrExpression.OrExpression_1_0 returns NULL
	 *     XorExpression returns NULL
	 *     XorExpression.XorExpression_1_0 returns NULL
	 *     AndExpression returns NULL
	 *     AndExpression.AndExpression_1_0 returns NULL
	 *     NotExpression returns NULL
	 *     ComparisonExpression returns NULL
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NULL
	 *     AddOrSubtractExpression returns NULL
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns NULL
	 *     MultiplyDivideModuloExpression returns NULL
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns NULL
	 *     PowerOfExpression returns NULL
	 *     PowerOfExpression.PowerOfExpression_1_0 returns NULL
	 *     UnaryAddOrSubtractExpression returns NULL
	 *     StringListNullOperatorExpression returns NULL
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns NULL
	 *     PropertyOrLabelsExpression returns NULL
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns NULL
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns NULL
	 *     Atom returns NULL
	 *     Literal returns NULL
	 *
	 * Constraint:
	 *     {NULL}
	 */
	protected void sequence_Literal(ISerializationContext context, NULL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns NULL
	 *
	 * Constraint:
	 *     propertyLookups+=PropertyLookup+
	 */
	protected void sequence_Literal_PropertyExpression(ISerializationContext context, NULL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LoadCSVQuery returns LoadCSVQuery
	 *
	 * Constraint:
	 *     (loadCSV=LoadCSV singleQuery=SingleQuery)
	 */
	protected void sequence_LoadCSVQuery(ISerializationContext context, LoadCSVQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.LOAD_CSV_QUERY__LOAD_CSV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.LOAD_CSV_QUERY__LOAD_CSV));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.LOAD_CSV_QUERY__SINGLE_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.LOAD_CSV_QUERY__SINGLE_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadCSVQueryAccess().getLoadCSVLoadCSVParserRuleCall_0_0(), semanticObject.getLoadCSV());
		feeder.accept(grammarAccess.getLoadCSVQueryAccess().getSingleQuerySingleQueryParserRuleCall_1_0(), semanticObject.getSingleQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns LoadCSV
	 *     ReadingClause returns LoadCSV
	 *     LoadCSV returns LoadCSV
	 *
	 * Constraint:
	 *     (withHeaders?=LoadCSVWithHeaders? expression=Expression variable=VariableDeclaration fieldterminator=STRING_LITERAL?)
	 */
	protected void sequence_LoadCSV(ISerializationContext context, LoadCSV semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapLiteralEntry returns MapLiteralEntry
	 *
	 * Constraint:
	 *     (key=PropertyKeyName value=Expression)
	 */
	protected void sequence_MapLiteralEntry(ISerializationContext context, MapLiteralEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getKeyPropertyKeyNameParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns MapLiteral
	 *     Expression returns MapLiteral
	 *     OrExpression returns MapLiteral
	 *     OrExpression.OrExpression_1_0 returns MapLiteral
	 *     XorExpression returns MapLiteral
	 *     XorExpression.XorExpression_1_0 returns MapLiteral
	 *     AndExpression returns MapLiteral
	 *     AndExpression.AndExpression_1_0 returns MapLiteral
	 *     NotExpression returns MapLiteral
	 *     ComparisonExpression returns MapLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MapLiteral
	 *     AddOrSubtractExpression returns MapLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns MapLiteral
	 *     MultiplyDivideModuloExpression returns MapLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns MapLiteral
	 *     PowerOfExpression returns MapLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns MapLiteral
	 *     UnaryAddOrSubtractExpression returns MapLiteral
	 *     StringListNullOperatorExpression returns MapLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns MapLiteral
	 *     PropertyOrLabelsExpression returns MapLiteral
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns MapLiteral
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns MapLiteral
	 *     Atom returns MapLiteral
	 *     Literal returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     (entries+=MapLiteralEntry entries+=MapLiteralEntry*)?
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapLiteralEntry entries+=MapLiteralEntry*)? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_MapLiteral_PropertyExpression(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Match
	 *     ReadingClause returns Match
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (optional?='OPTIONAL'? pattern=Pattern hints+=Hint* where=Where?)
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MergeAction returns MergeAction
	 *
	 * Constraint:
	 *     ((action='MATCH' | action='CREATE') set=Set)
	 */
	protected void sequence_MergeAction(ISerializationContext context, MergeAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Merge
	 *     UpdatingClause returns Merge
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (patternPart=PatternPart mergeActions+=MergeAction*)
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MultiPartQuery
	 *     Query returns MultiPartQuery
	 *     RegularQuery returns MultiPartQuery
	 *     RegularQuery.CombinedQuery_1_0 returns MultiPartQuery
	 *     SingleQuery returns MultiPartQuery
	 *     MultiPartQuery returns MultiPartQuery
	 *
	 * Constraint:
	 *     (subQueries+=MultiPartSubQuery+ singlePartQuery=SinglePartQuery)
	 */
	protected void sequence_MultiPartQuery(ISerializationContext context, MultiPartQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiPartSubQuery returns MultiPartSubQuery
	 *
	 * Constraint:
	 *     (readingClauses+=ReadingClause* updatingClauses+=UpdatingClause* withPart=With)
	 */
	protected void sequence_MultiPartSubQuery(ISerializationContext context, MultiPartSubQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiplyDivideModuloExpression
	 *     OrExpression returns MultiplyDivideModuloExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplyDivideModuloExpression
	 *     XorExpression returns MultiplyDivideModuloExpression
	 *     XorExpression.XorExpression_1_0 returns MultiplyDivideModuloExpression
	 *     AndExpression returns MultiplyDivideModuloExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplyDivideModuloExpression
	 *     NotExpression returns MultiplyDivideModuloExpression
	 *     ComparisonExpression returns MultiplyDivideModuloExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MultiplyDivideModuloExpression
	 *     AddOrSubtractExpression returns MultiplyDivideModuloExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns MultiplyDivideModuloExpression
	 *     MultiplyDivideModuloExpression returns MultiplyDivideModuloExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns MultiplyDivideModuloExpression
	 *
	 * Constraint:
	 *     (left=MultiplyDivideModuloExpression_MultiplyDivideModuloExpression_1_0 (operator='*' | operator='/' | operator='%') right=PowerOfExpression)
	 */
	protected void sequence_MultiplyDivideModuloExpression(ISerializationContext context, MultiplyDivideModuloExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeLabel returns NodeLabel
	 *
	 * Constraint:
	 *     labelName=LabelName
	 */
	protected void sequence_NodeLabel(ISerializationContext context, NodeLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeLabelAccess().getLabelNameLabelNameParserRuleCall_1_0(), semanticObject.getLabelName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodePattern returns NodePattern
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration? nodeLabels+=NodeLabel* properties=Properties?)
	 */
	protected void sequence_NodeLabels_NodePattern(ISerializationContext context, NodePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NodeLabelsExpression
	 *     OrExpression returns NodeLabelsExpression
	 *     OrExpression.OrExpression_1_0 returns NodeLabelsExpression
	 *     XorExpression returns NodeLabelsExpression
	 *     XorExpression.XorExpression_1_0 returns NodeLabelsExpression
	 *     AndExpression returns NodeLabelsExpression
	 *     AndExpression.AndExpression_1_0 returns NodeLabelsExpression
	 *     NotExpression returns NodeLabelsExpression
	 *     ComparisonExpression returns NodeLabelsExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NodeLabelsExpression
	 *     AddOrSubtractExpression returns NodeLabelsExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns NodeLabelsExpression
	 *     MultiplyDivideModuloExpression returns NodeLabelsExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns NodeLabelsExpression
	 *     PowerOfExpression returns NodeLabelsExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns NodeLabelsExpression
	 *     UnaryAddOrSubtractExpression returns NodeLabelsExpression
	 *     StringListNullOperatorExpression returns NodeLabelsExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns NodeLabelsExpression
	 *     PropertyOrLabelsExpression returns NodeLabelsExpression
	 *
	 * Constraint:
	 *     (left=PropertyOrLabelsExpression_NodeLabelsExpression_2_0 nodeLabels+=NodeLabel+)
	 */
	protected void sequence_NodeLabels_PropertyOrLabelsExpression(ISerializationContext context, NodeLabelsExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RemoveItemLabel
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabels+=NodeLabel+)
	 */
	protected void sequence_NodeLabels_RemoveItem(ISerializationContext context, RemoveItemLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetItem returns SetItem
	 *
	 * Constraint:
	 *     (
	 *         (propertyExpression=PropertyExpression expression=Expression) | 
	 *         (variable=VariableDeclaration expression=Expression) | 
	 *         (variable=VariableDeclaration expression=Expression) | 
	 *         (variable=VariableDeclaration nodeLabels+=NodeLabel+)
	 *     )
	 */
	protected void sequence_NodeLabels_SetItem(ISerializationContext context, SetItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NodePropertyExistenceConstraint
	 *     Command returns NodePropertyExistenceConstraint
	 *     CreateNodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *     NodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_NodePropertyExistenceConstraint(ISerializationContext context, NodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_9_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     XorExpression returns NotExpression
	 *     XorExpression.XorExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     NotExpression returns NotExpression
	 *
	 * Constraint:
	 *     (operator='NOT' left=NotExpression)
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NOT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NOT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NOT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NOT_EXPRESSION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getOperatorNOTKeyword_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getNotExpressionAccess().getLeftNotExpressionParserRuleCall_0_2_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NullOperatorExpression returns IsNotNullExpression
	 *
	 * Constraint:
	 *     {IsNotNullExpression}
	 */
	protected void sequence_NullOperatorExpression(ISerializationContext context, IsNotNullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NullOperatorExpression returns IsNullExpression
	 *
	 * Constraint:
	 *     {IsNullExpression}
	 */
	protected void sequence_NullOperatorExpression(ISerializationContext context, IsNullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.OrExpression_1_0 returns NumberLiteral
	 *     XorExpression returns NumberLiteral
	 *     XorExpression.XorExpression_1_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.AndExpression_1_0 returns NumberLiteral
	 *     NotExpression returns NumberLiteral
	 *     ComparisonExpression returns NumberLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NumberLiteral
	 *     AddOrSubtractExpression returns NumberLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns NumberLiteral
	 *     MultiplyDivideModuloExpression returns NumberLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns NumberLiteral
	 *     PowerOfExpression returns NumberLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns NumberLiteral
	 *     UnaryAddOrSubtractExpression returns NumberLiteral
	 *     StringListNullOperatorExpression returns NumberLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns NumberLiteral
	 *     PropertyOrLabelsExpression returns NumberLiteral
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns NumberLiteral
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns NumberLiteral
	 *     Atom returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNumberParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     (value=Number propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_NumberLiteral_PropertyExpression(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 operator='OR' right=XorExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getOperatorORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Order returns Order
	 *
	 * Constraint:
	 *     (orderBy+=SortItem orderBy+=SortItem*)
	 */
	protected void sequence_Order(ISerializationContext context, Order semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns Parameter
	 *     Expression returns Parameter
	 *     OrExpression returns Parameter
	 *     OrExpression.OrExpression_1_0 returns Parameter
	 *     XorExpression returns Parameter
	 *     XorExpression.XorExpression_1_0 returns Parameter
	 *     AndExpression returns Parameter
	 *     AndExpression.AndExpression_1_0 returns Parameter
	 *     NotExpression returns Parameter
	 *     ComparisonExpression returns Parameter
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Parameter
	 *     AddOrSubtractExpression returns Parameter
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Parameter
	 *     MultiplyDivideModuloExpression returns Parameter
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Parameter
	 *     PowerOfExpression returns Parameter
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Parameter
	 *     UnaryAddOrSubtractExpression returns Parameter
	 *     StringListNullOperatorExpression returns Parameter
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Parameter
	 *     PropertyOrLabelsExpression returns Parameter
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Parameter
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Parameter
	 *     Atom returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME_X | parameter=Number)
	 */
	protected void sequence_Parameter(ISerializationContext context, io.codekontor.opencypher.xtext.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Parameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME_X | parameter=Number) propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Parameter_PropertyExpression(ISerializationContext context, io.codekontor.opencypher.xtext.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParenthesizedExpression
	 *     OrExpression returns ParenthesizedExpression
	 *     OrExpression.OrExpression_1_0 returns ParenthesizedExpression
	 *     XorExpression returns ParenthesizedExpression
	 *     XorExpression.XorExpression_1_0 returns ParenthesizedExpression
	 *     AndExpression returns ParenthesizedExpression
	 *     AndExpression.AndExpression_1_0 returns ParenthesizedExpression
	 *     NotExpression returns ParenthesizedExpression
	 *     ComparisonExpression returns ParenthesizedExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ParenthesizedExpression
	 *     AddOrSubtractExpression returns ParenthesizedExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns ParenthesizedExpression
	 *     MultiplyDivideModuloExpression returns ParenthesizedExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns ParenthesizedExpression
	 *     PowerOfExpression returns ParenthesizedExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns ParenthesizedExpression
	 *     UnaryAddOrSubtractExpression returns ParenthesizedExpression
	 *     StringListNullOperatorExpression returns ParenthesizedExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns ParenthesizedExpression
	 *     PropertyOrLabelsExpression returns ParenthesizedExpression
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns ParenthesizedExpression
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns ParenthesizedExpression
	 *     Atom returns ParenthesizedExpression
	 *     ParenthesizedExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesizedExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     (expression=Expression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ParenthesizedExpression_PropertyExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PatternComprehension
	 *     OrExpression returns PatternComprehension
	 *     OrExpression.OrExpression_1_0 returns PatternComprehension
	 *     XorExpression returns PatternComprehension
	 *     XorExpression.XorExpression_1_0 returns PatternComprehension
	 *     AndExpression returns PatternComprehension
	 *     AndExpression.AndExpression_1_0 returns PatternComprehension
	 *     NotExpression returns PatternComprehension
	 *     ComparisonExpression returns PatternComprehension
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PatternComprehension
	 *     AddOrSubtractExpression returns PatternComprehension
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns PatternComprehension
	 *     MultiplyDivideModuloExpression returns PatternComprehension
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns PatternComprehension
	 *     PowerOfExpression returns PatternComprehension
	 *     PowerOfExpression.PowerOfExpression_1_0 returns PatternComprehension
	 *     UnaryAddOrSubtractExpression returns PatternComprehension
	 *     StringListNullOperatorExpression returns PatternComprehension
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns PatternComprehension
	 *     PropertyOrLabelsExpression returns PatternComprehension
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns PatternComprehension
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns PatternComprehension
	 *     Atom returns PatternComprehension
	 *     PatternComprehension returns PatternComprehension
	 *
	 * Constraint:
	 *     (pathVariable=VariableDeclaration? pattern=RelationshipsPattern where=Where? expression=Expression)
	 */
	protected void sequence_PatternComprehension(ISerializationContext context, PatternComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns PatternComprehension
	 *
	 * Constraint:
	 *     (pathVariable=VariableDeclaration? pattern=RelationshipsPattern where=Where? expression=Expression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PatternComprehension_PropertyExpression(ISerializationContext context, PatternComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternElementChain returns PatternElementChain
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPattern nodePattern=NodePattern)
	 */
	protected void sequence_PatternElementChain(ISerializationContext context, PatternElementChain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternElementChainAccess().getRelationshipPatternRelationshipPatternParserRuleCall_0_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getPatternElementChainAccess().getNodePatternNodePatternParserRuleCall_1_0(), semanticObject.getNodePattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternElement
	 *     AnonymousPatternPart returns PatternElement
	 *     PatternElement returns PatternElement
	 *
	 * Constraint:
	 *     (nodepattern=NodePattern chain+=PatternElementChain*)
	 */
	protected void sequence_PatternElement(ISerializationContext context, PatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternPart
	 *
	 * Constraint:
	 *     (var=VariableDeclaration part=AnonymousPatternPart)
	 */
	protected void sequence_PatternPart(ISerializationContext context, PatternPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternPartAccess().getVarVariableDeclarationParserRuleCall_0_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getPatternPartAccess().getPartAnonymousPatternPartParserRuleCall_0_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (patterns+=PatternPart patterns+=PatternPart*)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PeriodicCommitHint returns PeriodicCommitHint
	 *
	 * Constraint:
	 *     numberOfRowsPerCommit=DecimalInteger?
	 */
	protected void sequence_PeriodicCommitHint(ISerializationContext context, PeriodicCommitHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PowerOfExpression
	 *     OrExpression returns PowerOfExpression
	 *     OrExpression.OrExpression_1_0 returns PowerOfExpression
	 *     XorExpression returns PowerOfExpression
	 *     XorExpression.XorExpression_1_0 returns PowerOfExpression
	 *     AndExpression returns PowerOfExpression
	 *     AndExpression.AndExpression_1_0 returns PowerOfExpression
	 *     NotExpression returns PowerOfExpression
	 *     ComparisonExpression returns PowerOfExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PowerOfExpression
	 *     AddOrSubtractExpression returns PowerOfExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns PowerOfExpression
	 *     MultiplyDivideModuloExpression returns PowerOfExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns PowerOfExpression
	 *     PowerOfExpression returns PowerOfExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns PowerOfExpression
	 *
	 * Constraint:
	 *     (left=PowerOfExpression_PowerOfExpression_1_0 operator='^' right=UnaryAddOrSubtractExpression)
	 */
	protected void sequence_PowerOfExpression(ISerializationContext context, PowerOfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.POWER_OF_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getOperatorCircumflexAccentKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getRightUnaryAddOrSubtractExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcedureName returns ProcedureName
	 *
	 * Constraint:
	 *     (namespace=Namespace name=SYMBOLIC_NAME_X)
	 */
	protected void sequence_ProcedureName(ISerializationContext context, ProcedureName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAMESPACE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureNameAccess().getNamespaceNamespaceParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getProcedureNameAccess().getNameSYMBOLIC_NAME_XParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=VariableDeclaration accumulatorExpression=Expression idInColl=IdInColl expression=Expression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_Reduce(ISerializationContext context, Reduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+ propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns AllShortestPaths
	 *
	 * Constraint:
	 *     (patternElement=PatternElement propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_ShortestPathPattern(ISerializationContext context, AllShortestPaths semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns ShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns StringLiteral
	 *
	 * Constraint:
	 *     (value=STRING_LITERAL propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyLookup returns PropertyLookup
	 *
	 * Constraint:
	 *     ((propertyKeyName=PropertyKeyName (propertyOperator='?' | propertyOperator='!')) | propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_PropertyLookup(ISerializationContext context, PropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PropertyLookupExpression
	 *     OrExpression returns PropertyLookupExpression
	 *     OrExpression.OrExpression_1_0 returns PropertyLookupExpression
	 *     XorExpression returns PropertyLookupExpression
	 *     XorExpression.XorExpression_1_0 returns PropertyLookupExpression
	 *     AndExpression returns PropertyLookupExpression
	 *     AndExpression.AndExpression_1_0 returns PropertyLookupExpression
	 *     NotExpression returns PropertyLookupExpression
	 *     ComparisonExpression returns PropertyLookupExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PropertyLookupExpression
	 *     AddOrSubtractExpression returns PropertyLookupExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns PropertyLookupExpression
	 *     MultiplyDivideModuloExpression returns PropertyLookupExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns PropertyLookupExpression
	 *     PowerOfExpression returns PropertyLookupExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns PropertyLookupExpression
	 *     UnaryAddOrSubtractExpression returns PropertyLookupExpression
	 *     StringListNullOperatorExpression returns PropertyLookupExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns PropertyLookupExpression
	 *     PropertyOrLabelsExpression returns PropertyLookupExpression
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns PropertyLookupExpression
	 *
	 * Constraint:
	 *     (left=PropertyOrLabelsExpression_PropertyLookupExpression_1_0 propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyOrLabelsExpression(ISerializationContext context, PropertyLookupExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryOptions returns AllOptions
	 *
	 * Constraint:
	 *     (explain?='EXPLAIN' | profile?='PROFILE' | cypherOption+=CypherOption)*
	 */
	protected void sequence_QueryOptions(ISerializationContext context, AllOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeLiteral returns RangeLiteral
	 *
	 * Constraint:
	 *     (lower=Number? (variableLength?='..' upper=Number?)?)
	 */
	protected void sequence_RangeLiteral(ISerializationContext context, RangeLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Reduce
	 *     OrExpression returns Reduce
	 *     OrExpression.OrExpression_1_0 returns Reduce
	 *     XorExpression returns Reduce
	 *     XorExpression.XorExpression_1_0 returns Reduce
	 *     AndExpression returns Reduce
	 *     AndExpression.AndExpression_1_0 returns Reduce
	 *     NotExpression returns Reduce
	 *     ComparisonExpression returns Reduce
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Reduce
	 *     AddOrSubtractExpression returns Reduce
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Reduce
	 *     MultiplyDivideModuloExpression returns Reduce
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Reduce
	 *     PowerOfExpression returns Reduce
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Reduce
	 *     UnaryAddOrSubtractExpression returns Reduce
	 *     StringListNullOperatorExpression returns Reduce
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Reduce
	 *     PropertyOrLabelsExpression returns Reduce
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns Reduce
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns Reduce
	 *     Atom returns Reduce
	 *     Reduce returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=VariableDeclaration accumulatorExpression=Expression idInColl=IdInColl expression=Expression)
	 */
	protected void sequence_Reduce(ISerializationContext context, Reduce semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorVariableDeclarationParserRuleCall_2_0(), semanticObject.getAccumulator());
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorExpressionExpressionParserRuleCall_4_0(), semanticObject.getAccumulatorExpression());
		feeder.accept(grammarAccess.getReduceAccess().getIdInCollIdInCollParserRuleCall_6_0(), semanticObject.getIdInColl());
		feeder.accept(grammarAccess.getReduceAccess().getExpressionExpressionParserRuleCall_8_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CombinedQuery
	 *     Query returns CombinedQuery
	 *     RegularQuery returns CombinedQuery
	 *
	 * Constraint:
	 *     (singleQuery=RegularQuery_CombinedQuery_1_0 union+=Union+)
	 */
	protected void sequence_RegularQuery(ISerializationContext context, CombinedQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipDetail returns RelationshipDetail
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration? optional?='?'? (relTypeNames+=RelTypeName relTypeNames+=RelTypeName*)? range=RangeLiteral? properties=Properties?)
	 */
	protected void sequence_RelationshipDetail_RelationshipTypes(ISerializationContext context, RelationshipDetail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPatternSyntax returns RelationshipPatternSyntax
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? variable=VariableDeclaration relType=RelType outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPatternSyntax(ISerializationContext context, RelationshipPatternSyntax semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPattern returns RelationshipPattern
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? detail=RelationshipDetail? outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPattern(ISerializationContext context, RelationshipPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RelationshipPropertyExistenceConstraint
	 *     Command returns RelationshipPropertyExistenceConstraint
	 *     CreateRelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *     RelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPatternSyntax propertyExpression=PropertyExpression)
	 */
	protected void sequence_RelationshipPropertyExistenceConstraint(ISerializationContext context, RelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_6_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationshipsPattern
	 *     OrExpression returns RelationshipsPattern
	 *     OrExpression.OrExpression_1_0 returns RelationshipsPattern
	 *     XorExpression returns RelationshipsPattern
	 *     XorExpression.XorExpression_1_0 returns RelationshipsPattern
	 *     AndExpression returns RelationshipsPattern
	 *     AndExpression.AndExpression_1_0 returns RelationshipsPattern
	 *     NotExpression returns RelationshipsPattern
	 *     ComparisonExpression returns RelationshipsPattern
	 *     ComparisonExpression.ComparisonExpression_1_0 returns RelationshipsPattern
	 *     AddOrSubtractExpression returns RelationshipsPattern
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns RelationshipsPattern
	 *     MultiplyDivideModuloExpression returns RelationshipsPattern
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns RelationshipsPattern
	 *     PowerOfExpression returns RelationshipsPattern
	 *     PowerOfExpression.PowerOfExpression_1_0 returns RelationshipsPattern
	 *     UnaryAddOrSubtractExpression returns RelationshipsPattern
	 *     StringListNullOperatorExpression returns RelationshipsPattern
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns RelationshipsPattern
	 *     PropertyOrLabelsExpression returns RelationshipsPattern
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns RelationshipsPattern
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns RelationshipsPattern
	 *     Atom returns RelationshipsPattern
	 *     RelationshipsPattern returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+)
	 */
	protected void sequence_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RemoveItemProperty
	 *
	 * Constraint:
	 *     propertyExpression=PropertyExpression
	 */
	protected void sequence_RemoveItem(ISerializationContext context, RemoveItemProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_PROPERTY__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_PROPERTY__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveItemAccess().getPropertyExpressionPropertyExpressionParserRuleCall_1_1_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Remove
	 *     UpdatingClause returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     (removeItems+=RemoveItem removeItems+=RemoveItem*)
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnBody returns ReturnBody
	 *
	 * Constraint:
	 *     (distinct?='DISTINCT'? returnItems=ReturnItems order=Order? skip=Skip? limit=Limit?)
	 */
	protected void sequence_ReturnBody(ISerializationContext context, ReturnBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItem returns ReturnItem
	 *
	 * Constraint:
	 *     (expression=Expression alias=VariableDeclaration?)
	 */
	protected void sequence_ReturnItem(ISerializationContext context, ReturnItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItems returns ReturnItems
	 *
	 * Constraint:
	 *     ((all='*' items+=ReturnItem*) | (items+=ReturnItem items+=ReturnItem*))
	 */
	protected void sequence_ReturnItems(ISerializationContext context, ReturnItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     (return='RETURN' body=ReturnBody)
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RETURN__RETURN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RETURN__RETURN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RETURN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RETURN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getReturnRETURNKeyword_0_0(), semanticObject.getReturn());
		feeder.accept(grammarAccess.getReturnAccess().getBodyReturnBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Set
	 *     UpdatingClause returns Set
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (setItems+=SetItem setItems+=SetItem*)
	 */
	protected void sequence_Set(ISerializationContext context, io.codekontor.opencypher.xtext.openCypher.Set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns AllShortestPaths
	 *     AnonymousPatternPart returns AllShortestPaths
	 *     ShortestPathPattern returns AllShortestPaths
	 *     Expression returns AllShortestPaths
	 *     OrExpression returns AllShortestPaths
	 *     OrExpression.OrExpression_1_0 returns AllShortestPaths
	 *     XorExpression returns AllShortestPaths
	 *     XorExpression.XorExpression_1_0 returns AllShortestPaths
	 *     AndExpression returns AllShortestPaths
	 *     AndExpression.AndExpression_1_0 returns AllShortestPaths
	 *     NotExpression returns AllShortestPaths
	 *     ComparisonExpression returns AllShortestPaths
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AllShortestPaths
	 *     AddOrSubtractExpression returns AllShortestPaths
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns AllShortestPaths
	 *     MultiplyDivideModuloExpression returns AllShortestPaths
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns AllShortestPaths
	 *     PowerOfExpression returns AllShortestPaths
	 *     PowerOfExpression.PowerOfExpression_1_0 returns AllShortestPaths
	 *     UnaryAddOrSubtractExpression returns AllShortestPaths
	 *     StringListNullOperatorExpression returns AllShortestPaths
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns AllShortestPaths
	 *     PropertyOrLabelsExpression returns AllShortestPaths
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns AllShortestPaths
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns AllShortestPaths
	 *     Atom returns AllShortestPaths
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, AllShortestPaths semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_1_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns ShortestPath
	 *     AnonymousPatternPart returns ShortestPath
	 *     ShortestPathPattern returns ShortestPath
	 *     Expression returns ShortestPath
	 *     OrExpression returns ShortestPath
	 *     OrExpression.OrExpression_1_0 returns ShortestPath
	 *     XorExpression returns ShortestPath
	 *     XorExpression.XorExpression_1_0 returns ShortestPath
	 *     AndExpression returns ShortestPath
	 *     AndExpression.AndExpression_1_0 returns ShortestPath
	 *     NotExpression returns ShortestPath
	 *     ComparisonExpression returns ShortestPath
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ShortestPath
	 *     AddOrSubtractExpression returns ShortestPath
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns ShortestPath
	 *     MultiplyDivideModuloExpression returns ShortestPath
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns ShortestPath
	 *     PowerOfExpression returns ShortestPath
	 *     PowerOfExpression.PowerOfExpression_1_0 returns ShortestPath
	 *     UnaryAddOrSubtractExpression returns ShortestPath
	 *     StringListNullOperatorExpression returns ShortestPath
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns ShortestPath
	 *     PropertyOrLabelsExpression returns ShortestPath
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns ShortestPath
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns ShortestPath
	 *     Atom returns ShortestPath
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_0_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SinglePartQuery
	 *     Query returns SinglePartQuery
	 *     RegularQuery returns SinglePartQuery
	 *     RegularQuery.CombinedQuery_1_0 returns SinglePartQuery
	 *     SingleQuery returns SinglePartQuery
	 *     SinglePartQuery returns SinglePartQuery
	 *
	 * Constraint:
	 *     ((readingClauses+=ReadingClause* return=Return) | (readingClauses+=ReadingClause* updatingClauses+=UpdatingClause+ return=Return?))
	 */
	protected void sequence_SinglePartQuery(ISerializationContext context, SinglePartQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     skip=Expression
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkipAccess().getSkipExpressionParserRuleCall_1_0(), semanticObject.getSkip());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortItem returns SortItem
	 *
	 * Constraint:
	 *     (expression=Expression (sort='DESCENDING' | sort='DESC' | sort='ASCENDING' | sort='ASC')?)
	 */
	protected void sequence_SortItem(ISerializationContext context, SortItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StandaloneCall
	 *     Query returns StandaloneCall
	 *     StandaloneCall returns StandaloneCall
	 *
	 * Constraint:
	 *     ((invocation=ExplicitProcedureInvocation | invocation=ImplicitProcedureInvocation) yieldItems=YieldItems?)
	 */
	protected void sequence_StandaloneCall(ISerializationContext context, StandaloneCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StartPoint returns StartPoint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration lookup=Lookup)
	 */
	protected void sequence_StartPoint(ISerializationContext context, StartPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartPointAccess().getVariableVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getStartPointAccess().getLookupLookupParserRuleCall_2_0(), semanticObject.getLookup());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Start
	 *     ReadingClause returns Start
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (startPoint+=StartPoint startPoint+=StartPoint* where=Where?)
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringListNullOperatorExpression
	 *     OrExpression returns StringListNullOperatorExpression
	 *     OrExpression.OrExpression_1_0 returns StringListNullOperatorExpression
	 *     XorExpression returns StringListNullOperatorExpression
	 *     XorExpression.XorExpression_1_0 returns StringListNullOperatorExpression
	 *     AndExpression returns StringListNullOperatorExpression
	 *     AndExpression.AndExpression_1_0 returns StringListNullOperatorExpression
	 *     NotExpression returns StringListNullOperatorExpression
	 *     ComparisonExpression returns StringListNullOperatorExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringListNullOperatorExpression
	 *     AddOrSubtractExpression returns StringListNullOperatorExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns StringListNullOperatorExpression
	 *     MultiplyDivideModuloExpression returns StringListNullOperatorExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns StringListNullOperatorExpression
	 *     PowerOfExpression returns StringListNullOperatorExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns StringListNullOperatorExpression
	 *     UnaryAddOrSubtractExpression returns StringListNullOperatorExpression
	 *     StringListNullOperatorExpression returns StringListNullOperatorExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns StringListNullOperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         left=StringListNullOperatorExpression_StringListNullOperatorExpression_1_0 
	 *         (expressions+=StringOperatorExpression | expressions+=ListOperatorExpression | expressions+=NullOperatorExpression)
	 *     )
	 */
	protected void sequence_StringListNullOperatorExpression(ISerializationContext context, StringListNullOperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.OrExpression_1_0 returns StringLiteral
	 *     XorExpression returns StringLiteral
	 *     XorExpression.XorExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.AndExpression_1_0 returns StringLiteral
	 *     NotExpression returns StringLiteral
	 *     ComparisonExpression returns StringLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringLiteral
	 *     AddOrSubtractExpression returns StringLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns StringLiteral
	 *     MultiplyDivideModuloExpression returns StringLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns StringLiteral
	 *     PowerOfExpression returns StringLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns StringLiteral
	 *     UnaryAddOrSubtractExpression returns StringLiteral
	 *     StringListNullOperatorExpression returns StringLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns StringLiteral
	 *     PropertyOrLabelsExpression returns StringLiteral
	 *     PropertyOrLabelsExpression.PropertyLookupExpression_1_0 returns StringLiteral
	 *     PropertyOrLabelsExpression.NodeLabelsExpression_2_0 returns StringLiteral
	 *     Atom returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRING_LITERALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringOperatorExpression returns ContainsExpression
	 *
	 * Constraint:
	 *     right=PropertyOrLabelsExpression
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, ContainsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrLabelsExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringOperatorExpression returns EndsWithExpression
	 *
	 * Constraint:
	 *     right=PropertyOrLabelsExpression
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, EndsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrLabelsExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringOperatorExpression returns InCollectionExpression
	 *
	 * Constraint:
	 *     right=PropertyOrLabelsExpression
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, InCollectionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrLabelsExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringOperatorExpression returns RegExpMatchingExpression
	 *
	 * Constraint:
	 *     right=PropertyOrLabelsExpression
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, RegExpMatchingExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrLabelsExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringOperatorExpression returns StartsWithExpression
	 *
	 * Constraint:
	 *     right=PropertyOrLabelsExpression
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, StartsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrLabelsExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryAddOrSubtractExpression
	 *     OrExpression returns UnaryAddOrSubtractExpression
	 *     OrExpression.OrExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     XorExpression returns UnaryAddOrSubtractExpression
	 *     XorExpression.XorExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     AndExpression returns UnaryAddOrSubtractExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     NotExpression returns UnaryAddOrSubtractExpression
	 *     ComparisonExpression returns UnaryAddOrSubtractExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     AddOrSubtractExpression returns UnaryAddOrSubtractExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     MultiplyDivideModuloExpression returns UnaryAddOrSubtractExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     PowerOfExpression returns UnaryAddOrSubtractExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     UnaryAddOrSubtractExpression returns UnaryAddOrSubtractExpression
	 *
	 * Constraint:
	 *     ((operator='+' | operator='-') left=UnaryAddOrSubtractExpression)
	 */
	protected void sequence_UnaryAddOrSubtractExpression(ISerializationContext context, UnaryAddOrSubtractExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Union returns Union
	 *
	 * Constraint:
	 *     (all?='ALL'? singleQuery=SingleQuery)
	 */
	protected void sequence_Union(ISerializationContext context, Union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UniqueConstraint
	 *     Command returns UniqueConstraint
	 *     CreateUniqueConstraint returns UniqueConstraint
	 *     UniqueConstraint returns UniqueConstraint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_UniqueConstraint(ISerializationContext context, UniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_7_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Unwind
	 *     ReadingClause returns Unwind
	 *     Unwind returns Unwind
	 *
	 * Constraint:
	 *     (expression=Expression variable=VariableDeclaration)
	 */
	protected void sequence_Unwind(ISerializationContext context, Unwind semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnwindAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getUnwindAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     name=SYMBOLIC_NAME_X
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameSYMBOLIC_NAME_XParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VersionNumber returns VersionNumber
	 *
	 * Constraint:
	 *     versionNumber=Number
	 */
	protected void sequence_VersionNumber(ISerializationContext context, VersionNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionNumberAccess().getVersionNumberNumberParserRuleCall_0(), semanticObject.getVersionNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns With
	 *     With returns With
	 *
	 * Constraint:
	 *     (returnBody=ReturnBody where=Where?)
	 */
	protected void sequence_With(ISerializationContext context, With semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns XorExpression
	 *     OrExpression returns XorExpression
	 *     OrExpression.OrExpression_1_0 returns XorExpression
	 *     XorExpression returns XorExpression
	 *     XorExpression.XorExpression_1_0 returns XorExpression
	 *
	 * Constraint:
	 *     (left=XorExpression_XorExpression_1_0 operator='XOR' right=AndExpression)
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.XOR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExpressionAccess().getOperatorXORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YieldItem returns YieldItem
	 *
	 * Constraint:
	 *     (field=ProcedureResultField? variable=VariableDeclaration)
	 */
	protected void sequence_YieldItem(ISerializationContext context, YieldItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YieldItems returns YieldItems
	 *
	 * Constraint:
	 *     (items+=YieldItem items+=YieldItem*)?
	 */
	protected void sequence_YieldItems(ISerializationContext context, YieldItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
